{"version":3,"sources":["storage/sqlite-database-wrapper.js"],"names":[],"mappings":"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","file":"storage/sqlite-database-wrapper.js","sourcesContent":["const METADATA_SCHEMA =\n  'CREATE TABLE IF NOT EXISTS _ololord_metadata (name TEXT PRIMARY KEY NOT NULL, type TEXT NOT NULL)';\nconst KEYS_SCHEMA = 'CREATE TABLE IF NOT EXISTS _ololord_keys (key TEXT PRIMARY KEY NOT NULL, value TEXT)';\n\nexport default class SQLiteDatabaseWrapper {\n  constructor(client, adapter) {\n    this._client = client;\n    this._adapter = adapter;\n    this._initialized = false;\n    this._transactionQueue = [];\n    this._currentTransaction = false;\n  }\n\n  async _awaitClient() {\n    if (this._initialized) {\n      return;\n    }\n    this._client = await this._client;\n    await this._runRaw(`BEGIN TRANSACTION`);\n    await this._runRaw(METADATA_SCHEMA);\n    await this._runRaw(KEYS_SCHEMA);\n    await this._runRaw(`COMMIT TRANSACTION`);\n    this._initialized = true;\n  }\n\n  async _runRaw(statement, ...params) {\n    return new Promise((resolve, reject) => {\n      this._client.run(statement, params, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  async run(...args) {\n    await this._awaitClient();\n    return await this._runRaw(...args);\n  }\n\n  async get(statement, ...params) {\n    await this._awaitClient();\n    return new Promise((resolve, reject) => {\n      this._client.get(statement, params, (err, row) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(row);\n        }\n      });\n    });\n  }\n\n  async all(statement, ...params) {\n    await this._awaitClient();\n    return new Promise((resolve, reject) => {\n      this._client.all(statement, params, (err, rows) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(rows);\n        }\n      });\n    });\n  }\n\n  async _checkTransactionQueue() {\n    if (this._transactionQueue.length <= 0) {\n      this._currentTransaction = false;\n      return;\n    }\n    let next = this._transactionQueue.shift();\n    this._currentTransaction = true;\n    await this._awaitClient();\n    try {\n      await this._runRaw(`BEGIN ${next.type || ''} TRANSACTION`);\n      let state;\n      next.resolve({\n        state: state,\n        commit: () => {\n          return new Promise((resolve, reject) => {\n            this._runRaw(`COMMIT TRANSACTION`).then(() => {\n              state = true;\n              resolve();\n              this._checkTransactionQueue();\n            }).catch((err) => {\n              reject(err);\n              this._checkTransactionQueue();\n            });\n          });\n        },\n        rollback: () => {\n          return new Promise((resolve, reject) => {\n            this._runRaw(`ROLLBACK TRANSACTION`).then(() => {\n              state = false;\n              resolve();\n              this._checkTransactionQueue();\n            }).catch((err) => {\n              reject(err);\n              this._checkTransactionQueue();\n            });\n          });\n        }\n      });\n    } catch (err) {\n      next.reject(err);\n    }\n  }\n\n  async _transaction(transactionType) {\n    let promise = new Promise((resolve, reject) => {\n      this._transactionQueue.push({\n        resolve: resolve,\n        reject: reject,\n        type: transactionType || ''\n      });\n    });\n    if (!this._currentTransaction) {\n      this._checkTransactionQueue();\n    }\n    return promise;\n  }\n\n  async transaction(f) {\n    let t;\n    try {\n      t = await this._transaction();\n      let result;\n      let committed = false;\n      await f.call(this._adapter, (res) => {\n        committed = true;\n        result = res;\n      }, (res) => {\n        committed = false;\n        result = res;\n      });\n      if (committed) {\n        await t.commit();\n      } else {\n        await t.rollback();\n      }\n      return result;\n    } catch (err) {\n      if (t && typeof t.state === 'undefined') {\n        try {\n          await t.rollback();\n        } catch (err) {\n          throw err;\n        }\n      }\n      throw err;\n    }\n  }\n}\n"],"sourceRoot":"/source/"}