{"version":3,"sources":["helpers/fs-watcher.js"],"names":["FSWatcher","path","synchronous","asynchronous","existsSync","on","exists","require","default","error","stack","fileName","resetWatcher","watcher","removeAllListeners","close","watch","type","split","pop","emit"],"mappings":";;;;;;;;AAAA;;AACA;;;;AACA;;;;;;;;;;;;;;IAEqBA,S;;;;;0CACUC,I,EAAMC,W,EAAaC,Y,EAAc;AAC5D,UAAI,CAAC,aAAOC,UAAP,CAAkBH,IAAlB,CAAL,EAA8B;AAC5B;AACD;AACD,UAAI,OAAOE,YAAP,KAAwB,UAA5B,EAAwC;AACrC,YAAIH,SAAJ,CAAcC,IAAd,CAAD,CAAsBI,EAAtB,CAAyB,QAAzB,4CAAmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAEZ,aAAGC,MAAH,CAAUL,IAAV,CAFY;;AAAA;AAE3BK,wBAF2B;;AAAA,uBAG3BA,MAH2B;AAAA;AAAA;AAAA;;AAAA;AAAA,yBAIvBH,aAAaF,IAAb,CAJuB;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAO/BM,0BAAQ,UAAR,EAAoBC,OAApB,CAA4BC,KAA5B,CAAkC,YAAIC,KAAJ,eAAlC;;AAP+B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAnC;AAUD;AACD,aAAOR,YAAYD,IAAZ,CAAP;AACD;;;AAED,qBAAYU,QAAZ,EAAsB;AAAA;;AAAA;;AAEpB,UAAKA,QAAL,GAAgBA,QAAhB;AACA,UAAKC,YAAL;AAHoB;AAIrB;;;;;;;;;;;;;AAGC,oBAAI,KAAKC,OAAT,EAAkB;AAChB,uBAAKA,OAAL,CAAaC,kBAAb,CAAgC,QAAhC;AACA,uBAAKD,OAAL,CAAaE,KAAb;AACD;;uBACkB,aAAGT,MAAH,CAAU,KAAKK,QAAf,C;;;AAAfL,sB;;oBACCA,M;;;;;;;;AAGL,qBAAKO,OAAL,GAAe,aAAOG,KAAP,CAAa,KAAKL,QAAlB,CAAf;AACA,qBAAKE,OAAL,CAAaR,EAAb,CAAgB,QAAhB,EAA0B,UAACY,IAAD,EAAON,QAAP,EAAoB;AAC5C,sBAAI,aAAaM,IAAjB,EAAuB;AACrB,wBAAI,OAAKN,QAAL,CAAcO,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,OAAmCR,QAAvC,EAAiD;AAC/C;AACD;AACD,2BAAKC,YAAL;AACD,mBALD,MAKO,IAAI,aAAaK,IAAjB,EAAuB;AAC5B,2BAAKG,IAAL,CAAU,QAAV;AACD;AACF,iBATD;;;;;;;;;;;;;;;;;;;;;kBApCiBpB,S","file":"fs-watcher.js","sourcesContent":["import { EventEmitter } from 'events';\nimport FS from 'q-io/fs';\nimport FSSync from 'fs';\n\nexport default class FSWatcher extends EventEmitter {\n  static createWatchedResource(path, synchronous, asynchronous) {\n    if (!FSSync.existsSync(path)) {\n      return;\n    }\n    if (typeof asynchronous === 'function') {\n      (new FSWatcher(path)).on('change', async function() {\n        try {\n          let exists = await FS.exists(path);\n          if (exists) {\n            await asynchronous(path);\n          }\n        } catch (err) {\n          require('./logger').default.error(err.stack || err);\n        }\n      });\n    }\n    return synchronous(path);\n  }\n\n  constructor(fileName) {\n    super();\n    this.fileName = fileName;\n    this.resetWatcher();\n  }\n\n  async resetWatcher() {\n    if (this.watcher) {\n      this.watcher.removeAllListeners('change');\n      this.watcher.close();\n    }\n    let exists = await FS.exists(this.fileName);\n    if (!exists) {\n      return;\n    }\n    this.watcher = FSSync.watch(this.fileName);\n    this.watcher.on('change', (type, fileName) => {\n      if ('rename' === type) {\n        if (this.fileName.split('/').pop() !== fileName) {\n          return;\n        }\n        this.resetWatcher();\n      } else if ('change' === type) {\n        this.emit('change');\n      }\n    });\n  }\n}\n"]}